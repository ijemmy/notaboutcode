<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title>Retry ยังไงให้ปลอดภัย - Not About Code - Technical Leadership</title>
<meta name=renderer content="webkit">
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1">
<meta http-equiv=cache-control content="no-transform">
<meta http-equiv=cache-control content="no-siteapp">
<meta name=theme-color content="#f8f5ec">
<meta name=msapplication-navbutton-color content="#f8f5ec">
<meta name=apple-mobile-web-app-capable content="yes">
<meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec">
<meta name=author content="ijemmy"><meta name=description content="วันนี้นั่งคุยกับเพื่อนเรื่อง Retry รู้สึกว่าเป็นหัวข้อที่น่าสนใจดี
โจทย์คือเรามี External service ที่ไม่ค่อยสเถียรเท่าไร เวลาส่ง Request ไป วันดีคืนดีก็อาจจะ:
 พังแบบส่งสาเหตุการพังกลับมาให้ เช่น 5xx พร้อม error code พังแบบไม่มีอะไรตอบกลับมา ซึ่งสาเหตุอาจจะมาจากที่ระบบนั้นเดี้ยงไประหว่างการทำงาน หรือเน็ตเวิร์คเน่า  กรณีนี้ เรามีหลายทางเลือก
  เลือกที่จะจบการทำงาน แล้วแสดงผลให้ฝั่งผู้ใช้ของเรา (Client) รู้ว่าระบบมีปัญหา พร้อม Error code ซึ่งก็ถือว่ายอมรับได้ เพราะหากเราจำเป็นต้องการใช้ข้อมูลจาก External Service ยังไงก็ทำอะไรไม่ได้
  ทำการ Retry คือการส่ง Request ซ้ำโดยอัตโนมัติ หากเกิดข้อผิดพลาดในฝั่งของ External service ที่เราเรียกใช้
  Decouple ให้สองระบบเรียกกับแบบ Asynchronous โดยเอา Request ที่ไม่สำเร็จของเราไปเก็บไว้ใน Queue แล้ว Retry ใหม่ในภายหลัง
 "><meta name=keywords content="Hugo,theme,even">
<meta name=generator content="Hugo 0.89.4 with theme even">
<link rel=canonical href=http://www.notaboutcode.com/post/05-retry/>
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png>
<link rel=manifest href=/manifest.json>
<link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5>
<link href=/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css rel=stylesheet>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous>
<link rel=stylesheet href=/css/./css/custom.css>
<meta property="og:title" content="Retry ยังไงให้ปลอดภัย">
<meta property="og:description" content="
วันนี้นั่งคุยกับเพื่อนเรื่อง Retry รู้สึกว่าเป็นหัวข้อที่น่าสนใจดี
โจทย์คือเรามี External service ที่ไม่ค่อยสเถียรเท่าไร เวลาส่ง Request ไป วันดีคืนดีก็อาจจะ:

พังแบบส่งสาเหตุการพังกลับมาให้ เช่น 5xx พร้อม error code
พังแบบไม่มีอะไรตอบกลับมา ซึ่งสาเหตุอาจจะมาจากที่ระบบนั้นเดี้ยงไประหว่างการทำงาน หรือเน็ตเวิร์คเน่า

กรณีนี้ เรามีหลายทางเลือก


เลือกที่จะจบการทำงาน แล้วแสดงผลให้ฝั่งผู้ใช้ของเรา (Client) รู้ว่าระบบมีปัญหา พร้อม Error code ซึ่งก็ถือว่ายอมรับได้ เพราะหากเราจำเป็นต้องการใช้ข้อมูลจาก External Service ยังไงก็ทำอะไรไม่ได้


ทำการ Retry คือการส่ง Request ซ้ำโดยอัตโนมัติ หากเกิดข้อผิดพลาดในฝั่งของ External service ที่เราเรียกใช้


Decouple ให้สองระบบเรียกกับแบบ Asynchronous โดยเอา Request ที่ไม่สำเร็จของเราไปเก็บไว้ใน Queue แล้ว Retry ใหม่ในภายหลัง

">
<meta property="og:type" content="article">
<meta property="og:url" content="http://www.notaboutcode.com/post/05-retry/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2017-10-14T12:04:02+07:00">
<meta property="article:modified_time" content="2017-10-14T12:04:02+07:00">
<meta itemprop=name content="Retry ยังไงให้ปลอดภัย">
<meta itemprop=description content="
วันนี้นั่งคุยกับเพื่อนเรื่อง Retry รู้สึกว่าเป็นหัวข้อที่น่าสนใจดี
โจทย์คือเรามี External service ที่ไม่ค่อยสเถียรเท่าไร เวลาส่ง Request ไป วันดีคืนดีก็อาจจะ:

พังแบบส่งสาเหตุการพังกลับมาให้ เช่น 5xx พร้อม error code
พังแบบไม่มีอะไรตอบกลับมา ซึ่งสาเหตุอาจจะมาจากที่ระบบนั้นเดี้ยงไประหว่างการทำงาน หรือเน็ตเวิร์คเน่า

กรณีนี้ เรามีหลายทางเลือก


เลือกที่จะจบการทำงาน แล้วแสดงผลให้ฝั่งผู้ใช้ของเรา (Client) รู้ว่าระบบมีปัญหา พร้อม Error code ซึ่งก็ถือว่ายอมรับได้ เพราะหากเราจำเป็นต้องการใช้ข้อมูลจาก External Service ยังไงก็ทำอะไรไม่ได้


ทำการ Retry คือการส่ง Request ซ้ำโดยอัตโนมัติ หากเกิดข้อผิดพลาดในฝั่งของ External service ที่เราเรียกใช้


Decouple ให้สองระบบเรียกกับแบบ Asynchronous โดยเอา Request ที่ไม่สำเร็จของเราไปเก็บไว้ใน Queue แล้ว Retry ใหม่ในภายหลัง

"><meta itemprop=datePublished content="2017-10-14T12:04:02+07:00">
<meta itemprop=dateModified content="2017-10-14T12:04:02+07:00">
<meta itemprop=wordCount content="629">
<meta itemprop=keywords content="reliability,availability,retry,throttling,design,microservice,soa,"><meta name=twitter:card content="summary">
<meta name=twitter:title content="Retry ยังไงให้ปลอดภัย">
<meta name=twitter:description content="
วันนี้นั่งคุยกับเพื่อนเรื่อง Retry รู้สึกว่าเป็นหัวข้อที่น่าสนใจดี
โจทย์คือเรามี External service ที่ไม่ค่อยสเถียรเท่าไร เวลาส่ง Request ไป วันดีคืนดีก็อาจจะ:

พังแบบส่งสาเหตุการพังกลับมาให้ เช่น 5xx พร้อม error code
พังแบบไม่มีอะไรตอบกลับมา ซึ่งสาเหตุอาจจะมาจากที่ระบบนั้นเดี้ยงไประหว่างการทำงาน หรือเน็ตเวิร์คเน่า

กรณีนี้ เรามีหลายทางเลือก


เลือกที่จะจบการทำงาน แล้วแสดงผลให้ฝั่งผู้ใช้ของเรา (Client) รู้ว่าระบบมีปัญหา พร้อม Error code ซึ่งก็ถือว่ายอมรับได้ เพราะหากเราจำเป็นต้องการใช้ข้อมูลจาก External Service ยังไงก็ทำอะไรไม่ได้


ทำการ Retry คือการส่ง Request ซ้ำโดยอัตโนมัติ หากเกิดข้อผิดพลาดในฝั่งของ External service ที่เราเรียกใช้


Decouple ให้สองระบบเรียกกับแบบ Asynchronous โดยเอา Request ที่ไม่สำเร็จของเราไปเก็บไว้ใน Queue แล้ว Retry ใหม่ในภายหลัง

"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]-->
</head>
<body>
<div id=mobile-navbar class=mobile-navbar>
<div class=mobile-header-logo>
<a href=/ class=logo>Not About Code</a>
</div>
<div class=mobile-navbar-icon>
<span></span>
<span></span>
<span></span>
</div>
</div>
<nav id=mobile-menu class="mobile-menu slideout-menu">
<ul class=mobile-menu-list>
<a href=/>
<li class=mobile-menu-item>Home</li>
</a><a href=/post/>
<li class=mobile-menu-item>Archives</li>
</a><a href=/tags/>
<li class=mobile-menu-item>Tags</li>
</a><a href=/categories/>
<li class=mobile-menu-item>Categories</li>
</a><a href=/about/>
<li class=mobile-menu-item>About</li>
</a>
</ul>
</nav>
<div class=container id=mobile-panel>
<header id=header class=header>
<div class=logo-wrapper>
<a href=/ class=logo>Not About Code</a>
</div>
<nav class=site-navbar>
<ul id=menu class=menu>
<li class=menu-item>
<a class=menu-item-link href=/>Home</a>
</li><li class=menu-item>
<a class=menu-item-link href=/post/>Archives</a>
</li><li class=menu-item>
<a class=menu-item-link href=/tags/>Tags</a>
</li><li class=menu-item>
<a class=menu-item-link href=/categories/>Categories</a>
</li><li class=menu-item>
<a class=menu-item-link href=/about/>About</a>
</li>
</ul>
</nav>
</header>
<main id=main class=main>
<div class=content-wrapper>
<div id=content class=content>
<article class=post>
<header class=post-header>
<h1 class=post-title>Retry ยังไงให้ปลอดภัย</h1>
<div class=post-meta>
<span class=post-time> 2017-10-14 </span>
<div class=post-category>
<a href=/categories/system-design/> System Design </a>
</div>
</div>
</header>
<div class=post-toc id=post-toc>
<h2 class=post-toc-title>Contents</h2>
<div class="post-toc-content always-active">
<nav id=TableOfContents>
<ul>
<li><a href=#interval--number-of-retries>Interval & Number of retries</a></li>
<li><a href=#idempotent>Idempotent</a></li>
<li><a href=#exponential-back-off>Exponential Back-off</a></li>
<li><a href=#throttling--jitter>Throttling & Jitter</a></li>
<li><a href=#circuit-breaker>Circuit Breaker</a></li>
<li><a href=#ในทางปฏบต>ในทางปฏิบัติ</a></li>
</ul>
</nav>
</div>
</div>
<div class=post-content>
<p><img src=/img/covers/spiral-stairs-01.jpg alt="Photo by Nick Morris, from Unsplash.com"></p>
<p>วันนี้นั่งคุยกับเพื่อนเรื่อง Retry รู้สึกว่าเป็นหัวข้อที่น่าสนใจดี</p>
<p>โจทย์คือเรามี External service ที่ไม่ค่อยสเถียรเท่าไร เวลาส่ง Request ไป วันดีคืนดีก็อาจจะ:</p>
<ol>
<li>พังแบบส่งสาเหตุการพังกลับมาให้ เช่น 5xx พร้อม error code</li>
<li>พังแบบไม่มีอะไรตอบกลับมา ซึ่งสาเหตุอาจจะมาจากที่ระบบนั้นเดี้ยงไประหว่างการทำงาน หรือเน็ตเวิร์คเน่า</li>
</ol>
<p>กรณีนี้ เรามีหลายทางเลือก</p>
<ol>
<li>
<p>เลือกที่จะจบการทำงาน แล้วแสดงผลให้ฝั่งผู้ใช้ของเรา (Client) รู้ว่าระบบมีปัญหา พร้อม Error code ซึ่งก็ถือว่ายอมรับได้ เพราะหากเราจำเป็นต้องการใช้ข้อมูลจาก External Service ยังไงก็ทำอะไรไม่ได้</p>
</li>
<li>
<p>ทำการ Retry คือการส่ง Request ซ้ำโดยอัตโนมัติ หากเกิดข้อผิดพลาดในฝั่งของ External service ที่เราเรียกใช้</p>
</li>
<li>
<p>Decouple ให้สองระบบเรียกกับแบบ Asynchronous โดยเอา Request ที่ไม่สำเร็จของเราไปเก็บไว้ใน Queue แล้ว Retry ใหม่ในภายหลัง</p>
</li>
</ol>
<p>สมมติว่าเราเลือกวิธีที่ 2. ซึ่งเหมือนไม่ซับซ้อนเหมือนวิธีที่ 3.</p>
<p>มองผิวเผิน เราก็แค่วนลูบ Sleep แล้วเรียกซ้ำๆ แต่เมื่อระบบสเกลขึ้นไปในระดับใหญ่ การ Retry อัตโนมัติอาจนำมาซึ่งความวิบัติที่ไม่คาดคิดได้&mldr;</p>
<p>เลยเป็นมาของบันทึกฉบับนี้ ว่าเราควรพิจารณาอะไรบ้างในการ Retry อัตโนมัติ</p>
<h1 id=interval--number-of-retries>Interval & Number of retries</h1>
<p>เวลาจะทำ Retry อัตโนมัติ สิ่งแรกที่ต้องตัดสินใจก่อนคือจะรอเท่าไรก่อน Retry (Interval) และจะทำการ Retry กี่ครั้ง ก่อนจะหยุด</p>
<p>ซึ่งตัวเลขนี้ไม่มีสูตรตายตัวที่แน่นอน ขึ้นอยู่กับลักษณะของเซอร์วิซเรา โดยกรณีนี้ ผมจะเริ่มจากการ Retry หลังจากได้ Error แล้วไป 50ms และทำการ Retry ทั้งหมด 3 ครั้ง</p>
<p>หากผ่านไปสามครั้งแล้ว ยังมีปัญหาอยู่ ก็ต้องยอมแสดง Error code กลับไปยังฝั่งผู้ใช้ว่าทำงานไม่ได้</p>
<h1 id=idempotent>Idempotent</h1>
<p>หลังจากเขียนโค้ดเสร็จเรียบร้อยแล้ว ทดสอบผ่าน เอาขึ้นระบบจริง ปรากฏว่าเจอบั๊ก</p>
<p>บั๊กที่ว่าคือ บางครั้ง Request ที่ยิงไปยัง External Service เกิดขึ้น 2-3 ครั้ง แทนที่จะเป็นครั้งเดียว</p>
<p>กรณีนี้เกิดขึ้นเพราะบางครั้ง ฝั่ง External Service ได้ข้อมูลของเราเรียบร้อย และทำงานเสร็จแล้ว แต่พอส่งผลกลับ ข้อมูลกลับมาไม่ถึงด้วยเหตุผลอะไรก็ตามแต่</p>
<p>ฝั่งเราเอง พอไมไ่ด้ผลลัพธ์กลับมา ก็คิดว่าเป็น Timeout จึงตัดสินใจส่งข้อมูลใหม่ไปอีกรอบ</p>
<p>เลยกลายเป็นว่า External Service ได้รับ Request เดี่ยวกันสองรอบ ลองนึกภาพว่านี่เป็นคำสั่งการโอนเงินในธนาคาร ลูกค้าเจอแบบนี้เข้าไปคงไม่สนุกด้วย</p>
<p>วิธีการแก้ที่ถูกต้องคือตัว API ของ External Service จะต้องเป็น Idempotent</p>
<p>Idempotent เป็นคุณสมบัติที่หาก Request อันเดียวกันถูกส่งซ้ำๆไปมากกว่า 1 ครั้ง ผลลัพธ์การทำงานจะต้องเกิดขึ้นแค่ครั้งเดียว</p>
<p>การทำให้เซอร์วิซเป็น Idempotent นั้นมีวิธีหลายแบบ ยาวพอที่จะเขียนบล็อคแยกออกไปได้เลย อันนี้ขอให้ผู้อ่านลองไปศึกษาเอาเองนะครับ</p>
<p>ในกรณีที่เราไม่สามารถทำให้ External Service เป็น Idempotent ได้ เราจะต้องไม่ Retry ในกรณีที่ Error เป็นชนิด Timeout</p>
<h1 id=exponential-back-off>Exponential Back-off</h1>
<p>หลังจากแก้ไขโค้ดและเอาขึ้นระบบจริงอีกรอบ ผมได้ทำการเก็บบันทึกจำนวนครั้ง Retry ไว้ เพื่อที่จะได้เอาข้อมูลไปเช็คว่าการ Retry ช่วยแก้ปัญหาได้จริงรึเปล่า</p>
<p>เมื่อเอาข้อมูลไปเช็ค ปรากฏว่า ทุกครั้งที่ระบบทำการ Retry จะทำทั้งหมด 2 ครั้งตลอดก่อนจะผ่าน โดยการ Retry ครั้งที่ 1 จะไม่สำเร็จเป็นประจำ</p>
<p>พอคุยกับทา External Service เขาบอกว่าสาเหตุที่ Request ได้ Error มาจากว่าช่วงนั้นระบบได้รับ Request จากหลายๆที่เยอะมาก ทำให้ประมวลผลไม่ทัน พอเรารีบ Retry ใน 50 ms ระบบก็ยังคงยุ่งเกินไปอยู่ดี ทำให้ครั้งแรกยังไงก็ไม่ผ่าน</p>
<p>ไม่ยาก ผมแก้โค้ดให้ Retry ใน 100 ms แทน เอาขึ้นระบบจริง ปรากฏว่าจำนวน Retry เฉลี่ยนลดจาก 2 ครั้งเป็น 1 ครั้ง ทุกคนมีความสุข</p>
<p>ผ่านไปประมาณ 1 เดือน อยู่ดีๆกราฟจำนวน Retry เฉลี่ยก็เพิ่มขึ้นจาก 1 เป็น 1.5 ฝั่ง External Service แจ้งมาว่า เดี๋ยวนี้ระบบได้รับ Request เยอะมาก รอแค่ 100 ms ไม่พอแล้ว หากรอจำนวนเท่านี้ มันจะสำเร็จบ้าง ไม่สำเร็จบ้าง ให้เปลี่ยนค่ารอเป็น 200 ms แทน</p>
<p>แต่ 200 ms นี่มันช้ามาก ถ้าผมทำการรอแบบนี้ทุกครั้ง Request ที่มีการ Retry ของผมจะทำให้ Latency ของผมสูงขึ้นโดยใช่เหตุ</p>
<p>หนึ่งในวิธีจัดการกับปัญหานี้คือใช้ Exponential backoff คือหลังจากรอครั้งแรก การรอครั้งถัดๆไปให้ใช้วิธีการเพิ่มปริมาณการรอแบบ Exponential แทนที่จะเป็น Linear</p>
<p>คือจากเดิมรอ</p>
<blockquote>
<p>50 ms, 50 ms, 50 ms</p>
</blockquote>
<p>ก็อาจจะเปลี่ยนเป็น</p>
<blockquote>
<p>50 ms, 100 ms, 250 ms</p>
</blockquote>
<p>ตัวเลขอันนี้ผมตั้งไว้เพราะผมพอเดาได้ว่าต้องรอประมาณเท่าไร กรณีที่ไม่รู้อะไรเลยว่าควรรอเท่าไร เราอาจจะตั้งให้เป็น</p>
<blockquote>
<p>base x (2^1-1 , 2^2-1, 2^3-1,&mldr;)</p>
</blockquote>
<p>ตัวอย่างเช่น base เป็น 50 ms ก็จะได้</p>
<blockquote>
<p>50 ms (50x1), 150 ms (50x3), 350 ms (50x7)</p>
</blockquote>
<h1 id=throttling--jitter>Throttling & Jitter</h1>
<p>สมมติว่า External Service ที่เราคุยกันสามารถรองรับการทำงานได้แค่ประมาณ 100 Request ต่อวินาที</p>
<p>วันดีคืนดี ฝั่ง Client เรียกเรามา 100 Request พอเราส่ง Request ต่อไปพรวดเดียวให้ External Service</p>
<p>ผลคือ ฝั่งนั้นไม่สามารถตอบกลับมาได้ หรือถึงตอบกลับมาได้ก็ใช้เวลา (Response Time) นานกว่าปกติ เพราะต้องจัดการ Request เกือบเต็ม Capacity ติดๆกัน</p>
<p>อาการนี้เรียกว่า Contention</p>
<p>ถ้าเกิดโชคร้าย ไม่มี Request ไหนสำเร็จเลย ระบบของเราก็จะเข้าการทำ Retry ต่อ หลังจากผ่านไป 50 ms ก็ส่งติดกันไปอีก 100 Requests เหมือนเดิมทำให้ระบบ External Service ตอบไม่ได้อีก กลายเป็น DoS (Denial Of Service) ระบบตัวเองไปซะงั้น</p>
<p>หนึ่งในวิธีแก้ กรณีที่เรารู้ลิมิตของฝั่ง External Service คือการทำ Throttling</p>
<p>Throttling คือการจำกัดจำนวนการเรียกของฝั่ง Client</p>
<p>ในที่นี้เราอาจจะเซ็ต Throttling ให้อยู่ที่ 70 Requests ต่อวินาที หากผู้ใช้เรียกมาเกิน Request ที่เกินมาก็จะได้รับคำตอบทันทีว่าเกินลิมิต</p>
<p>แต่หากว่าจังหวะนั้น มีเซอร์วิซอื่นต้องการเรียกใช้ External Service และส่งอีก 30 Requests เข้ามาพร้อมๆกันล่ะ? สุดท้ายเราก็ต้องกลับมา Retry อยู่ดี</p>
<p>สุดท้ายแล้ว เราก็ต้องหาวิธี Retry ที่ไม่ก่อให้เกิด Contention อยู่ดี</p>
<p>โดยวิธีแก้ Contention จากการ Retry นี้เรียกว่า &ldquo;Jitter&rdquo;</p>
<p>Jitter คือการสุ่มค่าการรอก่อนส่ง Retry กลับไป เช่น สุ่มรอระหว่าง 0-50 ms แทนที่จะรอ 50 ms พร้อมกันหมด</p>
<p>ดังนั้น จำนวนการรอจะเป็น</p>
<blockquote>
<p>0-50 mx, 0-100ms, 0-250 ms</p>
</blockquote>
<p>วิธีนี้เรียกว่า &ldquo;Full Jitter&rdquo; โดยจะทำให้ Request ของเรามีการกระจายตัวดีขึ้น ไม่กระจุกตัวพรวดเดียวให้เกิด Contention</p>
<p>อีกวิธีการที่คล้ายกันคือ &ldquo;Equal Jitter&rdquo; กับ &ldquo;Decorrelated Jitter&rdquo; ซึ่งถ้าใครสนใจรายละเอียด สามารถอ่านต่อได้<a href=https://www.awsarchitectureblog.com/2015/03/backoff.html>ที่นี่</a></p>
<p>โดยส่วนตัวแล้วผมรู้สึกว่า Full Jitter ทำงานได้ดีอยู่แล้ว และลอจิกเข้าใจง่ายกว่า แต่วิธีอื่นอาจจะดีกว่ามากๆได้ ขึ้นอยู่กับลักษณะของ External Service วิธีที่จะรู้ก็คือต้องทำการทดสอบดู</p>
<h1 id=circuit-breaker>Circuit Breaker</h1>
<p>เวลาผ่านไป โค้ดของผมทำงาานได้ดี แต่ฝั่ง External Service มีการปรับเปลี่ยนโครงสร้าง โดยแตกเป็น Micro Service ย่อยๆข้างใน</p>
<p>จากเดิมที่ผมเรียก</p>
<blockquote>
<p>Service A > External Service B</p>
</blockquote>
<p>ก็กลายเป็น</p>
<blockquote>
<p>Service A > External Service B1 > External Service B2 > External Service B3</p>
</blockquote>
<p>ซึ่งดูผิวเผินก็ไม่มีปัญหาอะไร แต่เผอิญว่า External Service B1-B2 ชอบเทคนิคการ Retry ของผมมาก เลยไปทำแบบเดียวกัน</p>
<p>วันหนึ่ง เซอร์วิซ B3 มีปริมาณ Request เยอะมากเพราะมันถูกเรียกใช้จาก MicroService อื่นๆด้วย พอจำนวนการเรียกใช้มันเยอะเกิน ก็เริ่มส่ง Error ติดๆกันไปสักพักหนึ่ง</p>
<p>Error นี้ถูกส่งกลับขึ้นไปเป็นทอดๆ ไปยังเซอร์วิซ B2, B1, และ A ของผม</p>
<p>โดย B2 จะทำการ Retry 3 ครั้ง ก่อนส่งกลับไปที่ B1 และ B1 ก็จะ Retry 3 ครั้ง ก่อนส่งกลับไปที่ A</p>
<p>พอเริ่มเห็นภาพหายนะหรือยังครับ?</p>
<p>เนื่องด้วยเซอร์วิซผมทำการ Retry อัตโนมัติ จึงเรียกซ้ำอีก ซึ่งนับรวมแล้ว B3 จะได้รับ Request รวมทั้งหมด 4 x 4 x 4 (1 ครั้งแรก Retry อีก 3 ครั้ง ทุกๆระดับ) = 64 ครั้ง จาก 1 Request ที่เข้า A</p>
<p>เป็นอัน DoS ระบบตัวเองเรียบร้อย</p>
<p>เพื่อป้องกันปัญหานี้ มีเทคนิคที่เรียกว่า <a href=https://martinfowler.com/bliki/CircuitBreaker.html>Circuit Breaker</a> คือ หากการเรียกไปที่เซอร์วิซใดๆเกิดปัญหาเกินจำนวนที่กำหนดเอาไว้ (เช่น 3 ครั้ง) ให้ทำการปิดการติดต่อเป็นระยะเวลาหนึ่ง</p>
<p>หากมี Request ใหม่ที่ต้องเรียกไปยังเซอร์วิซนั้นในช่วงระยะเวลาดังกล่าว ไม่ต้องทำการส่ง Request แต่ให้ส่ง Error กลับไปยังผู้เรียกเลย</p>
<p>พอผ่านระยะเวลานั้นไปแล้ว ให้ลองเริ่มส่ง Request อีกที</p>
<p>ถ้าผ่าน ก็ทำการเปิดเซอร์วิซนั้นให้เรียกตามปกติ แต่ถ้าไม่ผ่าน ก็ให้ปิดแล้วรอไปอีกช่วงระยะเวลาหนึ่ง ทำแบบนี้ไปเรื่อยๆ</p>
<p>วิธีนี้จะช่วยป้องกันการ DoS กันเองได้</p>
<h1 id=ในทางปฏบต>ในทางปฏิบัติ</h1>
<p>ในทางปฏิบัติ น่าจะมีคนทำ Opensource Library ในการทำ Retry Exponential Backoff + Jitter หรือ Circuit Breaker ให้ใช้ในภาษาของคุณแล้ว ถ้ามีก็หยิบไปใช้เลย เพราะการเขียนโค้ดพวกนี้ให้ถูกเป้ะๆนั้นใช้เวลานานอยู่ โดยเฉพาะอย่างยิ่งการใส่ Jitter ที่มีการยัด Randomness เข้าไป</p>
<p>หากไม่มีไลบรารี่ที่พอใจ ในบริษัทควรจะทำ Library กลางไว้ใช้กันเอง เพราะการทำ Service Oriented Architecture หรือ MicroService ปัญหาพวกนี้จะต้องเกิดขึ้นกับทุกทีม ทำทีเดียวให้ใช้กันทั้งบริษัทเลย</p>
</div>
<div class=post-copyright>
<p class=copyright-item>
<span class=item-title>Author</span>
<span class=item-content>ijemmy</span>
</p>
<p class=copyright-item>
<span class=item-title>LastMod</span>
<span class=item-content>
2017-10-14
</span>
</p>
<p class=copyright-item>
<span class=item-title>License</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span>
</p>
</div>
<footer class=post-footer>
<div class=post-tags>
<a href=/tags/reliability/>reliability</a>
<a href=/tags/availability/>availability</a>
<a href=/tags/retry/>retry</a>
<a href=/tags/throttling/>throttling</a>
<a href=/tags/design/>design</a>
<a href=/tags/microservice/>microservice</a>
<a href=/tags/soa/>soa</a>
</div>
<nav class=post-nav>
<a class=prev href=/post/06-career-start/>
<i class="iconfont icon-left"></i>
<span class="prev-text nav-default">โปรแกรมเมอร์มือใหม่ เรียนรู้อะไรดี ภาค 1</span>
<span class="prev-text nav-mobile">Prev</span>
</a>
<a class=next href=/post/04-choosing-language/>
<span class="next-text nav-default">ขึ้นโปรเจ็คใหม่ ใช้ภาษาอะไรดี</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i>
</a>
</nav>
</footer>
</article>
</div>
</div>
</main>
<footer id=footer class=footer>
<div class=social-links>
<a href=https://www.facebook.com/notaboutcode/ class="iconfont icon-facebook" title=facebook></a>
<a href=http://www.notaboutcode.com/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a>
</div>
<div class=copyright>
<span class=power-by>
Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a>
</span>
<span class=division>|</span>
<span class=theme-info>
Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a>
</span>
<span class=copyright-year>
&copy;
2017 -
2021<span class=heart><i class="iconfont icon-heart"></i></span><span>ijemmy</span>
</span>
</div>
</footer>
<div class=back-to-top id=back-to-top>
<i class="iconfont icon-up"></i>
</div>
</div>
<script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-108239205-1','auto'),ga('set','anonymizeIp',!0),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
</body>
</html>