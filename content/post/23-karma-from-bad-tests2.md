---
title: "เขียนเทสต์อย่างไรให้ไม่บาป (ฉบับที่ 2 System Integration Tests/End-to-End Tests)"
date: 2018-05-05T12:04:02+07:00
lastmod: 2018-05-05T12:04:02+07:00
draft: false
tags: ["CI", "CD", "Testing"]
categories: ["Continuous Delivery"]
---

![Photo by Chris Liverani on Unsplash](/img/covers/test-01.jpg)

จากประสบการณ์ส่วนตัว End-to-End(E2E) Tests เป็นตัวที่สร้างความปวดหัวให้กับผมอันดับที่หนึ่งเลย รองลงมาก็ System Integration Tests ตอนเขียนบทความนี้ฉบับแรก เลยตัดสินใจแยกเทสต์สองประเภทนี้ออกมาเขียนแยกเป็นอีกบทความเลย

บทความนี้ก็เหมมือนบทความที่แล้วครับ คือทำผิดมาเยอะ จนพอจะสรุปข้อผิดพลาดที่เคยทำไว้มาแชร์กัน ผู้อ่านจะได้หลบเลี่ยงกันได้

<!--more-->

# ควรอ่านอะไรมาก่อน

ถ้าใครที่เขียน Unit/Component/Integration/E2E Test เป็นประจำอยู่แล้ว ข้ามส่วนนี้ไปได้เลยครับ

แต่ถ้าใครที่ไม่ได้เขียนเทสต์เยอะๆ ผมแนะนำให้อ่านสองบทความนี้ก่อนครับ

* [บทความเรื่องคุณสมบัติของเทสต์]({{< relref "post/18-test-properties.md" >}})
* [เขียนเทสต์อย่างไรให้ไม่บาป ฉบับ Unit/Component Tests]({{< relref "post/18-test-properties.md" >}})

บทความนี้จะต่อขยายเนื้อหาจากสองบทความแรก เพราะปัญหาของ Unit/Component Tests ส่วนใหญ่ก็จะเกิดกับ Integration/E2E Tests เหมือนกัน (ยกเว้นเรื่อง Mock)

# นิยามของ System Integration Tests/End-to-End Tests

ก่อนอื่นมาทำความเข้าใจกันก่อนว่าเวลาผมพูดคำว่า System Integration Tests/End-to-End Tests ที่ผมพูดนี่มันหมายถึงอะไรกันแน่

เริ่มจากคำว่า Integration Test ก่อน (ไม่มีคำว่า **System**) นี่เป็นหนึ่งในคำที่สับสนที่สุดในวงการเลย ไม่เชื่อให้ไปถามคนในแต่ละทีมทีละคนดูว่าหมายถึงอะไร จะได้คำตอบที่กว้างมาก

* บางคนก็บอกว่าถ้าไม่เป็น Unit Test ก็เป็น Integration Test หมด (คือรวม Component Testing ด้วย)
* บางคนก็จะหมายถึงการเอา Component หลายๆอันมาต่อกันเป็น Service แล้วลองเทสต์ทั้ง Service ดู   
* บางคนก็จะหมายถึงเอา Service มารวมกันให้ครบเป็นระบบที่ทำงานได้ แล้วลองทดสอบดูว่ามันทำงานด้วยกันได้

ถ้าไปค้นวิกิดู จะได้นิยามว่า

> Integration testing is the phase in software testing in which individual *software modules* are combined and tested as a group

ซึ่งปัญหาของคำนี้ มันอยู่ที่คำว่า Module นี่แหละครับ เราจะมองว่า Class แต่ละคลาสเป็นหนึ่ง Module ก็ได้ หรือจะมองว่าคลาสหลายๆคลาสรวมกันเป็น หนึ่ง Module (เหมือน Package ใน Java) หรือมองว่าทุกๆอย่างรวมกันในหนึ่งเซอร์วิซเป็นหนึ่ง Module ก็ได้เหมือนกัน

อันนี้ใครคิดว่านิยามไหนถูก ผมว่าไม่สำคัญ สำคัญว่าคนในทีม (หรือในบริษัท) ควรจะมีนิยามเดียวกัน ว่าเวลาเราพูดว่า Integration Tests เนี่ย เรากำลังพูดถึงการ Integrate กันในระดับไหน

เพื่อเลี่ยงความสับสน ผมจะใช้คำว่า System Integration Tests (SIT) แทน ซึ่งในที่นี้ ผมหมายถึงการนำเซอร์วิซทุกอันมารันบนเซอร์เวอร์จริง (แค่ไม่ใช่บน Production) ให้มีการเรียกใช้งานกันระหว่างเซอร์วิซจริง แล้วก็ทดสอบเรียกแบบของจริงเลย

ถ้าระบบของเราเป็น Web Service การทดสอบนี้คือการเรียกใช้ผ่าน HTTP, RPC หรือ Protocol ที่จะต้องถูกใช้งานจริงๆบน Production

หากระบบของเรามี User Interface (UI) เช่น มีหน้าเว็บไซต์ แล้วเวลาดึงข้อมูลก็จะดึงผ่าน API Call  เราจะทดสอบด้วยการใช้เฟรมเวิร์คที่สามารถ Simulate การคลิกตามตำแหน่งต่างๆของเว็บไซต์เหมือนผู้ใช้งานใช้เว็บนั้นอยู่จริงๆ  (เช่น Selenium) กรณีนี้ผมจะเรียกว่า End-to-End Test (E2E)   อันนี้ผมยอมรับว่าเป็นชื่อที่ไม่ดีเท่าไร บางที่ก็อาจจะเรียกชื่ออื่น

ถ้าสรุปเป็นภาพ หน้าตาจะประมาณนี้ครับ

{{% imgcenter src="/img/diagrams/23-karma-from-bad-tests2/01-sit-vs-e2e.png" caption="เปรียบเทียบว่า SIT กับ E2E อยุ่ที่ระดับไหน" %}}

ตามนิยามนี้ เราจะเห็นได้ว่า ข้อแตกต่างของการทดสอบทั้งสองแบบนี้ คือตัวนึงเทสต์ในระดับ UI, ส่วนอีกตัวคือ Service API

ส่วนที่คล้ายกันคือ การทดสอบทั้งสองแบบจะใช้ระบบจริง รันบนเซอร์เวอร์จริง เรียกใช้ Dependency จริง (ซึ่งอาจจะมี Dependency ข้างหลังบ้างนอีก เช่น Service C เรียก D ต่อ)

ส่วนที่คล้ายกันนี้ทำให้เกิดปัญหาที่คล้ายๆกันครับ เช่น

1. เปราะ (ฺBrittleness) แก้อะไรนิดหน่อยก็พัง ยิ่ง E2E เนี่ย บางทีแก้ชื่อคลาสทีนึงก็พังแล้ว  
2. รันแล้วพังบ้างไม่พังบ้าง (Flakiness) ซึ่งสาเหตุอาจจะมาจากเทสต์โค้ดที่เขียนไม่ดีเอง หรือ Dependency ที่ไม่เสถียร
3. แกะยากมากว่าพังจากตรงไหน (Failure Isolation) เพราะเป็นได้ตั้งแต่โค้ดของเราไปจนถึง Dependencies (ซึ่งอาจเป็น Dependency ของ Dependency อีกทีที่มีปัญหา)
4. ช้า (Slowness) รันทีนานมาก ต้องบางโปรเจ็คต้องรันกันข้ามคืน พอพังทีก็ไม่แน่ใจว่ามาจาก Commit ไหนเพราะทั้งวันมีเป็นสิบ Commit

ทุกโปรเจ็คที่ผมทำมา ถ้าเขียน SIT/E2E Tests จะเจอปัญหานี้หมด มากน้อยไม่เหมือนกัน

หลังจากเราเข้าใจนิยามของสองคำนี้แล้ว ไปดูกันต่อครับ ว่าผมทำอะไรผิดมาบ้าง ถึงเจอปัญหาพวกนี้

# 1. Dependencies ไม่เสถียร เทสต์รันผ่านบ้างไม่ผ่านบ้าง
เวลารัน SIT/E2E  เราจะต้องมีการเรียกใช้งาน Dependency ตัวจริงที่ถูก Deploy บนเซอร์เวอร์จริง (Service B, C, D ในภาพข้างต้น) ดังนั้น ทีมที่ทำ SIT/E2E จะต้องมี Pre-Production Stage

Pre-Production Stage ที่ดี ควรจะเหมือนระบบจริงทุกอย่าง ต่างกันแค่ปริมาณเซอร์เวอร์ที่รันเพราะต้องรับ Load ที่ต่างกัน

ถ้าโชคดี ทีมเราเป็นคนคุมทุก Dependency ที่มีหมด เราก็จะสามารถจัดการจังหวะการรันเทสต์ หรือ Deploy ให้ไม่ชนกันได้ ซึ่งการันตีได้ว่าระหว่างที่รันเทสต์นั้น Dependency ทุกตัวที่เราใช้จะเสถียรหมด

แต่ในทางปฏิบัติ โปรดักต์ที่ใหญ่ๆ แต่ละ Dependency มักจะถูกดูแลโดยคนละทีม ทำให้ SIT/E2E ที่เคยรันผ่านตามปกติ อยู่ดีๆก็พังขึ้นมา เพราะ Dependency เกิดไม่เสถียรระหว่างที่รันพอดี

ตัวอย่างกรณีที่ทำให้เกิดการไม่เสถียรก็เช่น

1. Dependency มีการ Deploy ในขณะที่เรากำลังรันเทสต์อยู่
2. Dependency ดันมีเวอร์ชั่นใหม่ที่มีบั๊ก
3. มีการรันเทสต์ของ Dependency นั้นๆในจังหวะเดียวกันพอดี กรณีนี้อาจจะมีการเขียนข้อมูลทับซ้อนกันเอง หรือปริมาณ Load เกินกว่าที่ Dependency จะรับได้

ปัญหาแรก ถ้าฝั่ง Dependency ถูกออกแบบมาให้เป็น High Availability อยู่แล้ว ระหว่างที่ Deploy ก็จะไม่มี Downtime ทำให้ตัดปัญหาไปได้ ถ้าคุมเรื่อง Backward Compatibility กันดีๆ ก็จะไม่มีปัญหาอะไร

ปัญหาที่ 2 อันนี้ต้องมีการตกลงกันระหว่างทีมกันให้ดี ว่า Pre-Production Stage ตัวนี้จะต้องถูกใช้ในการทำ SIT/E2E ดังนั้น ที่ Stage นี้ จะต้องมีแต่การรันโค้ดที่ผ่านการทดสอบมาในระดับหนึ่งแล้ว ไม่ใช่ถูกใช้เป็นด่านแรกในการทดสอบ

ส่วนปัญหาที่ 3 อันนี้อาจจะแก้ได้ด้วยการตกลงว่าจะไม่รันเทสต์อย่างอื่นในระบบนี้ เก็บไว้สำหรับใช้ SIT/E2E อย่างเดียว

วิธีการแก้ปัญหาข้างบนทั้งหมด อยู่บนสมมติฐานว่าทุกทีมตกลงกันได้ว่าจะมี Pre-Production Stage ที่เสถียรให้สำหรับการทำ SIT/E2E

แต่หากทุกทีมตกลงกันไม่ได้ล่ะ บางทีมอาจจะบอกว่าตนมี Legacy System ที่ไม่มี Pre-Production Stage (แล้วแม่งเทสต์กันยังไง?) หรือฝั่ง Management อาจจะมองว่าประโยชน์ในการสร้าง Pre-Production Stage ไม่คุ้มกับเวลาที่ต้องใช้  หรืออาจจะต้องรออีกสัก 6 เดือน กว่าจะสั่งเซอร์เวอร์ได้

> "อยู่กับสิ่งที่มี ไม่ใช่สิ่งที่ฝัน" -- เพลงพี่บอย

ชีวิตจริงมันโหดร้าย กรณีที่เราแก้ไขที่ต้นเหตุไม่ได้ อาจจะต้องยอมลดเป้าหมายเราลงมาหน่อย ทางเลือกที่เป็นไปได้ก็มีอยู่สองทาง

1. กรณีที่ Test Fail ครั้งแรก รอสัก 2-3 วิ แล้วรันเทสต์ใหม่อีกรอบ หากพังซ้ำ ถึงค่อยใส่ Test ให้เป็น Fail  (อันนี้ก็ต้องแงะแต่ละ Testing Framework มาดู ว่าให้ใส่โค้ด Decorator เข้าไปได้ไหม)
2. Mock Dependency นั้นซะ อย่างน้อยก็ยังดีกว่าไม่มี Test เลย

ที่จริงผมเคยเห็นที่ทดสอบกับ Production ของ Dependency ด้วย แต่ผมแนะนำว่าอย่าเสี่ยงเลย ถ้าจำเป็นต้องทำถึงขนาดนั้นก็ยอม Mock ดีกว่า

# 2. Uncontrollable start condition
เคยเขียนไปแล้ว แต่ Side-Effect


# 3. No reusable components (ex. Page Object)
คล้ายๆเป็นลูกเมียน้อย

# 4. Don't Wait Properly
คิดว่าทุกอย่างเกิดขึ้นทันทีใน UI Test
Integration Test ข้ามระบบอาจจะมี Eventual consistency

# 5. ไม่รีบแก้ Flaky Tests
ไม่ปิดสาเหตุตั้งแต่เนิ่นๆ พอจำนวนเทสต์เยอะแล้วหาเจอยาก (อาจจะมีไซด์ Effect)

Reproduce ยากมาก เพราะมีเรื่อง Timing, Dependency เข้ามาเกี่ยวข้อง

Log ก็จะมีผล

# 6. เขียนเทสต์มากไป (all permutations)
ช้า เปราะ และดูแลยาก

สรุป
เอาเข้าจริง จะให้มันเพอร์เฟ็คเลย ด้วย Tool กับ Practice ที่เรามีอยู่ปัจจุบันนี้ ผมว่ายากมาก  
