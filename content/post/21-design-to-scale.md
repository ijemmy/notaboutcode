---
title: "การออกแบบระบบให้รับ Request เยอะๆ (Scalability)"
date: 2018-03-28T12:04:02+07:00
lastmod: 2018-04-01T12:04:02+07:00
draft: false
tags: ["system design", "architecture"]
categories: ["design"]
---

![Photo by Brandon Day on Unsplash](/img/covers/child-02.jpg)

กลับไทยคราวนี้ มีโอกาสกลับไปเป็น Guest Speaker ที่ภาควิชา

อาจารย์ให้อิสระในเรื่องของหัวข้อ เลยตัดสินใจว่าแทนที่จะลงไปในเรื่องของทฤษฏี อยากเล่าเรื่องที่มัน Practical และสนุกๆมากกว่า เผื่อน้องๆจะประทับใจมาทำสาย Software Engineering กันมากขึ้น (ปกติย้ายจบแล้วก็ไปสายอื่นกันซะเกือบครึ่ง)

หลังจากคิดอยู่หลายวัน ก็มาจบลงที่เรื่องของ Scalability

ไหนๆก็พูดเรื่องนี้แล้ว เลยเอาเนื้อหาบางส่วนมาสรุปเป็นบทความเสียเลย โดยบทความนี้ เราจะเริ่มต้นจากการทำความเข้าใจ Non-functional Requirement ด้าน Scalability ของระบบกันก่อน แล้วจึงค่อยๆออกแบบระบบให้ตอบโจทย์นี้ได้ ระหว่างทางก็จะแวะคุยกันถึงเรื่องศัพท์และทฤษฏีต่างๆที่เกี่ยวข้อง

<!--more-->

# ระบบลงทะเบียนเรียน
ในบทความนี้ เราจะคุยกันถึงเรื่องการออกแบบระบบลงทะเบียนเรียนของมหาวิทยาลัย เรื่องมีอยู่ว่า ทุกๆเทอมมหาวิทยาลัยจะเปิดให้นิสิตลงทะเบียนเรียน"พร้อมกัน" ผ่านทางเว็บไซต์ โดยปัจจุบัน มหาวิทยาลัยมีนิสิตรวมประมาณ 35,000 คน  

ก่อนการลงทะเบียนเรียน แต่ละคณะและภาควิชา จะส่งรหัสวิชา, ชื่อวิชา, และจำนวนนักเรียนที่รับได้ในรายวิชานั้นๆ ข้อมูลเหล่านี้จะถูกบันทึกลงในฐานข้อมูล และใช้ในการลงทะเบียนเรียน

ปัญหาหลักของระบบปัจจุบันคือ เมื่อถึงเวลาเปิดให้ลงทะเบียน เว็บจะล่มบ่อยมาก เพราะจะมีบางวิชาที่เป็นที่นิยมมาก นิสิตจะรีบกดลงทะเบียนให้เร็วที่สุด เพราะการลงทะเบียนเป็นแบบ First-come-first-serve ใครลงได้สำเร็จก่อนภายในจำนวนที่รับได้ในวิชานั้นๆก็จะได้เรียน ส่วนคนที่ลงไม่ทันก็อด หากเป็นวิชาบังคับที่ต้องเรียนในเทอมนั้นๆ ก็จะต้องไปติดต่ออาจารย์เพื่อขอลงเรียนเป็นกรณีพิเศษไป

โดยในบทความนี้ เราจะโฟกัสกันที่การออกแบบระบบที่ทำให้นิสิตสามารถลงทะเบียนเรียนพร้อมกันได้โดยไม่ทำให้ระบบล่ม

# ขั้นตอนการลงทะเบียนเรียน
ขั้นตอนข้างต้นเป็นแบบคร่าวๆนะครับ เอาเข้าจริง จะมีรายละเอียดเรื่องจำนวนหน่วยกิตที่นิสิตสามารถลงทะเบียนได้ การเลือกรายวิชาที่เหมาะสม

| ขั้นที่ | ผู้ใช้                     | ระบบ |
| :---| :-------------          |:---------------|
| 1 | เข้าสู่ระบบ | ตรวจสอบ Username และ Password ว่าถูกต้อง |
| 2 | คลิ๊กที่ลิ้งก์ "ลงทะเบียนเรียน" | ส่งหน้าเว็บเพจสำหรับลงทะเบียนเรียนให้กับผู้ใช้  |
| 3 | ผู้ใช้กรอกรหัสวิชา**ทุกวิชา** และกด Submit |  ตรวจสอบแต่ละวิชากับฐานข้อมูลว่าเต็มแล้วหรือยัง ถ้ายัง ให้บันทึกการลงทะเบียนวิชานั้นๆ แต่หากเต็มแล้ว ก็ไม่ทำการลงทะเบียนให้ หลังกจากตรวจสอบครบทุกวิชา ให้แสดงผลรหัสวิชาที่ลงทะเบียนเรียนสำเร็จ และไม่สำเร็จกลับไปยังผู้ใช้|
| 4 | ผู้ใช้เลือกจบการลงทะเบียน หรือส่งรหัสวิชาอื่นๆที่อยากลงทะเบียนเพิ่มเติม | ย้อนกลับไปข้อ 3 หรือจบการทำงาน |

# Sizing

Sizing เป็นการประเมิน Workload ของระบบแบบคร่าวๆ

เราเริ่มต้นด้วยสถาปัตยกรรมระบบแบบตรงไปตรงมาง่ายๆ คือแยก Server ออกมาไว้รับ Request และแยก Database ออกมาเพื่อทำ ตามรูปข้างล่าง

###todo ใส่รูป

ถ้าสมมติว่าลงทะเบียนไม่ทัน ต้องทำ ขั้นที่ 4 ซ้ำอีก 2 ครั้ง โดยเฉลี่ย ผู้ใช้จะต้องส่ง Request มาโดยเฉลี่ยประมาณ 6 ครั้ง (4 ขั้น + 2 ครั้ง) กว่าจะจบการลงทะเบียน

ปริมาณถ้าเราคำนวนคร่าวๆ ในช่วงเวลาหนึ่งนาที เราจะมี Request เข้ามา 35,000 คน x 6 ครั้ง = 210,000 Request ในหนึ่งนาที เฉลี่ยนๆแล้วระบบต้องรับโหลดได้ประมาณ 3,500 Request ต่อวินาที

เอาเข้าจริง เราต้องคำนวนเผื่ออนาคตด้วย จากสถิติย้อนหลัง เราอาจจะพอเดาได้ว่าปริมาณนิสิตจะเพิ่มขึ้นปีละประมาณ 5% ถ้าเราจะออกแบบระบบให้รองรับคนได้ใน 10 ปีข้างหน้า ค่า 35,000 อาจจะต้องปรับเป็น 57,000 (35,000 x 1.05^10)  หรือหากเราทราบว่ามหาวิทยาลัยอาจจะมีการเปิดสาขาใหม่ในอีกปีสองปีข้างหน้า เราก็ต้องเอามาบวกเพิ่มตรงนี้

ยังไม่รวมว่าผู้ใช้บางคนอาจจะมีพฤติกรรมแปลกๆ เช่นเปิดบอทไว้ใช้ลงทะเบียนเรียน ซึ่งถ้าเราไม่ทำการ Throttling อาจจะทำให้จำนวน Request พุ่งขึ้นทะลุยอดได้ง่ายๆ

อันนี้เป็นการประเมินโหลด (Sizing) แบบคร่าวๆ เพราะแต่ละ Request มีความ"หนัก" ต่อ Database ไม่เท่ากัน

ตัวอย่างเช่น ขั้นที่ 1 นั้นจะต้องมีการอ่านข้อมูล(Read)จาก Database เพื่อตรวจสอบว่ารหัสผ่านถูกต้องหนึ่งครั้ง

ในขณะที่ขั้นที่ 2 เซอร์เวอร์สามารถส่งหน้าเว็บเพจกลับได้เลย ถ้าหน้านี้ไม่ได้มีข้อมูลแบบ Dynamic เราก็ไม่ต้องอ่านข้อมูลจาก Database จึงถือว่า"เบา" มาก

ส่วนขั้นที่ 3 จะมีทั้งการ Read และ Write ใน Database หลายครั้ง (สำหรับแต่ละวิชา) โดยต้อง Read มาดูว่าเต็มรึเปล่าก่อน ถ้าเฉลี่ยแล้วนิสิตลงทะเบียนกันคนละประมาณ 6 วิชา จะต้องมีการอ่าน Database 6 ครั้ง (เว้นแต่เราจะทำการ Optimize Query) และทำการ  Write ประมาณ 1-6 ครั้ง

จะเห็นได้ว่า ส่วนที่หนักที่สุดต่อ Database คือขั้นตอนที่ 3 หากใช้วิธีการคำนวนคร่าวๆแบบด้านบน เราก็จะสามารถคำนวนจำนวน Read/Write per second โดยเฉลี่ยออกมาคร่าวๆได้

# Scalability & Bottleneck

มาเริ่มจากนิยามของคำว่า Scalability จาก Wikipedia กันก่อน

> Scalability is the capability of a system, network, or process to handle a growing amount of work, or its potential to be enlarged to accommodate that growth

ในระบบลงทะเบียนเรียน ระบบจะต้องจัดการปริมาณในช่วงลงทะเบียน (Peak Load) ได้ โดยไม่ล่ม

โดยปกติแล้ว ระบบที่รับ Request ไม่ไหวจนล่ม มักจะล่มอยู่ไม่กี่จุด ได้แก่

1. CPU
2. Memory
3. Disk I/O (Read/Write)
4. Network

เราเรียกทรัพยากร(Resource)เหล่านี้ว่าคอขวด (Bottleneck) ตัวอย่างเช่น ในระบบที่มี Request มากๆ แต่ละ Request ไม่มีการอ่านข้อมูลจาก Database ระบบอาจจะมีคอขวดอยู่ที่ CPU หรือ RAM ของเซอร์เวอร์

ในขณะที่ระบบที่ต้องมีการอัพเดตข้อมูลต่อเนื่องกันเร็วๆ อย่างระบบลงทะเบียน จองตั๋ว อันนี้คอขวดอาจจะอยู่ที่ Disk I/O ของ Database

กรณีที่เรามีระบบอยู่แล้ว สามารถทำ Load Test ได้ โดยเราสามารถทดลองยิง Request ใส่เข้าไปในระบบ แล้วเพิ่มจำนวนของ Request ขึ้นเรื่อยๆ จนถึงจุดที่ระบบไม่่สามารถรับได้ (หรือรับได้แต่ Latency ช้ามากกว่าที่จะยอมรับได้) ณ จุดนั้น เราก็เข้าไปเช็คดูว่า Resource ตัวไหนที่หมดก่อน

กรณที่เราไม่มีระบบอยู่ (หรือมีแต่ระบบจริงที่ Load Test ไม่ได้) อันนี้ก็ต้องนั่งเทียนเอาหน่อย อาจจะต้องไปเช็ค Benchmark ของเทคโนโลยีที่เราใช้แล้วกะๆเอา หรือใส่ Monitoring Tool เพื่อดูพฤติกรรมของระบบตอนที่มีคนใช้เยอะๆ ว่าทรัพยากรไหนเป็น Bottleneck

# เทคนิคการออกแบบระบบให้ Scale

## 1. Scaling vertically vs horizontally
จริงๆวิธีการแก้ปัญหาเรื่อง Scale ที่ง่ายที่สุด คือการอัดทรัพยากรเข้าไปเพิ่ม

ถ้า CPU ไม่พอ ก็เพิ่ม CPU ถ้า Memory ไม่พอ ก็เพิ่ม Memory เข้าไป

โดยสมัยก่อน การเพิ่มแบบนี้จะเป็นการอัพเกรดเครื่อง หรือย้ายไปเครื่องใหม่ที่มีเสป็คแรงขึ้น วิธีนี้เราอาจมองได้ว่าเป็นการทำให้เครื่องใหญ่ขึ้น ศัพท์เฉพาะคือการ Scale แบบ Vertically (แนวตั้ง)

###TODO รูป

การเพิ่มแบบแนวตั้งนี้มีปัญหาหลาายอย่าง ได้แก่

1. **เราจะไม่สามารถขยายเครื่องใหญ่ขึ้นได้ตลอดไป** หลังจากขยายขนาดเครื่องไปเรื่อยๆ ราคาจะแพงขึ้นในแบบ Exponential คุณไม่มีทางเอาเครื่องๆเดียวรับคำสั่งค้นหา Google ที่ (อาจจะเป็นไปได้ แต่เครื่องน่าจะใหญ่มากจนไม่สามารถก่อสร้างได้ในราคาที่เราสามารถจ่ายได้)
2. **มี Downtime ในการอัพเกรด** ณ จุดหนึ่งที่เมนบอร์ดใส่แรมครบแล้ว เราก็ต้องอัพเกรดโดยการเปลี่ยนไปยังเครื่องใหม่ โดยการเปลี่ยนไปยังเครื่องใหม่นี้จะต้องมี Downtime (ช่วงเวลาที่ต้องปิดปรับปรุงระบบ) ซึ่งอาจจะกินเวลาเป็นวัน
3. **เราต้องมีทรัพยากรเกินความจำเป็นตลอด** เช่นในระบบลงทะเบียนเรียนข้างต้น เราต้องวางระบบให้รองรับ 3,500 Request/วินาที ซึ่งปริมาณ Load ขนาดนี้จะเกิดขึ้นแค่เทอมละครั้ง แต่เราต้องมีเครื่องที่รับปริมาณ Request ที่สูงมากๆอยู่ตลอดเวลา  ส่วนเวลาอื่นๆ เครื่องก็ทำงานโดยไม่ได้ใช้ประสิทธิภาพเต็มที่

ดังนั้น การออกแบบสมัยใหม่เลยเน้นไปที่การเพิ่มแบบ Horizontally หรือแนวนอน

การเพิ่มแบบแนวนอนคือการใส่เซอร์เวอร์ใหม่เพิ่มเข้าไป โดยไม่ต้องแตะเซอร์เวอร์เก่า เวลามี Request จากฝั่งผู้ใช้ พวก Request นี้ก็จะโดนกระจายไปตามเซอร์เวอร์ต่างๆ

###TODO รูป

หากออกแบบมาดี การ Scale Horizontally นั้นจะตัดปัญหาข้อที่ 1 และ 2 ได้

ส่วนข้อ 3 ถ้าหากใช้ระบบ Cloud ที่สามารถปรับปริมาณทรัพยากรที่ใช้แบบอัตโนมัติได้ เช่น ปกติเราอาจจะรันระบบด้วยเซอร์เวอร์แค่สองตัว แต่พอเข้าสู่ช่วงลงทะเบียนเรียน เราจะเพิ่มปริมาณเซอร์เวอร์เป็นสิบตัวในวันแรกๆของการลงทะเบียน  ทำให้ลดค่าใช้จ่ายของเซอร์เวอร์ได้

## 3. Read Replica
ตัวอย่างการ Scale ข้างต้นนั้นอยู่ในส่วนของเซอร์เวอร์ แต่ถ้าส่วนที่เป็นคอขวดจริงๆคือส่วนของ Disk I/O ของ Database ล่ะ?

ปัญหานี้มีสามารถแก้ได้หลายทาง วิธีแรกที่จะคุยกันคือการทำ Read Replica  

วิธีนี้อาจจะคล้ายๆกับ Scaling Horizontally โดยเราจะทำการก็อบข้อมูลของ Database ทั้งหมด แยกมาไว้ในอีก Database หนึ่ง แล้วให้คำสั่งอ่าน (Read) วิ่งไป Database นี้แทน

หากมีการเขียน เราก็จะส่งไปที่ Database หลัก (เราจะเรียกกันว่า Master) แล้วตัว Master ก็จะทำการก็อบข้อมูลไปยัง Read Replica แบบ Asynchronous

วิธีนี้ดูผิวเผินอาจจะช่วยใช้แก้ปัญหาได้ แต่จริงๆแล้วจะมีปัญหาค่อนข้างมากเพราะการก็อบข้อมูลเป็นแบบ Asynchronous ที่เราควบคุมไม่ได้ว่าจะเสร็จเมื่อไร

ยกตัวอย่างเช่น หากเรามีวิชาที่คนแย่งกันลงทะเบียนมากๆ ณ จุดหนึ่ง Replica อาจจะมีคนลงทะเบียนที่ 80 จาก 100 คน  ทั้งๆที่ตัว Master อาจจะเต็มแล้ว แต่ยังไม่ได้ทำการก็อบข้อมูลมา เคสนี้ อาจจะทำให้เกิดการลงทะเบียนเกินได้แบบเยอะมาก

บางคนอาจจะได้ไอเดียว่า ถ้า Asynchronous มันมีปัญหา ก็ทำแบบ Synchronous สิ คือทุกครั้งที่ Write ให้ทำการอัพเดต Replica ให้เสร็จก่อน เวลาเกิดการ Read ครั้งถัดไป เราจะได้มั่นใจว่าการ Read ทุกครั้งได้ข้อมูลที่ตรงกัน (Consistency)

วิธีนี้แก้ปัญหาได้ แต่ค่าใช้จ่ายที่จะตามมาก็คือการเขียนจะต้องใช้เวลานานขึ้น (เพราะต้องเขียนทั้งสอง Database) และมีความซับซ้อนมากขึ้นเพราะต้องจัดการกรณีที่การเขียนลง Replica ไม่สำเร็จ (แต่ดันเขียนลง Master ไปแล้ว)

## 4. Caching
อีกหนึ่งทางเลือกคือการทำ Caching ข้อมูลที่ต้องใช้บ่อยๆ ไว้ใน Memory แทนที่จะเป็น Disk

ตัวอย่างเช่น หากเราค้นพบว่า Bottleneck คือ Disk I/O ของข้อมูลที่เราต้องใช้บ่อยมากในขั้นที่ 4  นั่นคือ จำนวนคนที่ลงทะเบียนเรียนไปแล้ว ในแต่ละรายวิชา

| รหัสวิชา | จำนวนคนที่ลงทะเบียนไปแล้ว                 | รับทั้งหมด |
| :---| :-------------          |:---------------|
| 2110332 | 30 | 120 |
| 3800250 | 50 | 50 |
| 2300150 | 55 | 60 |

ทางเลือกหนึ่งคือเราอาจเก็บข้อมูลส่วนนี้แยกไว้ใน Memory ของเซอร์เวอร์ ​(กรณีที่เรามั่นใจว่ามีเซอร์เวอร์แค่ตัวเดียว) หรือเก็บไว้ใน In-Memory Database (Redis, Memcached) ในกรณีที่เรามี Server หลายตัว

วิธีนี้ทำให้เราสามารถอ่านข้อมูลได้อย่างรวดเร็วกว่า แทนที่จะต้องติดต่อ Database ทุกครั้งว่ายังลงทะเบียนเพิ่มได้หรือเปล่า เราก็สามารถตรวจจากข้อมูลใน Memory ได้เลย ซึ่งจะเร็วกว่าเกือบพันเท่า ([การดึงข้อมูลใน Memory ใช้เวลาประมาณ 100 ns ในขณะท่ี Disk Read อยู่ที่ 150,000 ns](https://gist.github.com/jboner/2841832))

ความซับซ้อนที่เพิ่มขึ้นมา คือเวลาเราจะต้องเก็บข้อมูลอยู่สองที่ หากเกิดอะไรขึ้นระหว่างการเขียนข้อมูล อาจจะทำให้ข้อมูล Inconsistent ได้

## 5. Data Partitioning
หากเรามองปัญหาในอีกมุมหนึ่ง เราสามารถออกแบบข้อมูลของ Database ให้กระจายไปอยู่หลายๆเครื่องได้ เช่น

1. ข้อมูลวิชาบังคับของแต่ละภาค
2. ข้อมูลวิชาเลือก (Free Elective) ของทุกภาควิชา

เราอาจจะค้นพบว่า วิชาที่เกิดการแย่งลงมากๆ (มีการ Read/Write) เยอะๆ คือพวกวิชา Free Elective ซึ่งมีแค่ประมาณ​ 10% ของวิชาทั้งหมด

เราอาจจะแยกวิชาพวกนี้เข้าไปเก็บใน Database หนึ่งโดยเฉพาะ แล้วให้เซอร์เวอร์ติดต่อเซอร์เวอร์นี้แยกต่างหาก เวลาต้องการเช็คการลงทะเบียนเรียนเกี่ยวกับ Free Elect

วิธีนี้เป็นการกระจาย Load ในระบบด้วยคามรู้ใน Domain ของระบบ (เช่น เฟสบุ้ครู้ว่าเรามักจะค้นคนที่อยู่ประเทศเดียวกัน เฟสบุ้คก็อาจจะกระจายการเก็บข้อมูลให้คนในประเทศเดียวกันเก็บข้อมูลใน Database เดียวกัน)

กรณีที่เราไม่รู้อะไรเลย (ไม่รู้ว่าวิชาไหนคนแย่งกันมากๆ) ก็อาจจะทำการสุ่มกระจายข้อมูลเท่าๆกันลงบนทุก Database
