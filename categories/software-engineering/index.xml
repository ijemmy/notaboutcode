<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Software Engineering on Not About Code - Technical Leadership</title><link>https://www.notaboutcode.com/categories/software-engineering/</link><description>Recent content in Software Engineering on Not About Code - Technical Leadership</description><generator>Hugo -- gohugo.io</generator><language>th</language><lastBuildDate>Thu, 03 Mar 2022 15:05:28 +0100</lastBuildDate><atom:link href="https://www.notaboutcode.com/categories/software-engineering/index.xml" rel="self" type="application/rss+xml"/><item><title>คิดและวางแผนก่อน(แก้)โค้ด</title><link>https://www.notaboutcode.com/post/34-definition-of-success/</link><pubDate>Thu, 03 Mar 2022 15:05:28 +0100</pubDate><guid>https://www.notaboutcode.com/post/34-definition-of-success/</guid><description>วันนี้คุยกับเมนเตอร์เรื่องทำอย่างไรเราถึงจะสร้าง Impact จากงานที่เราทำได้ ทำยังไงให้เราก้าวจาก Senior เป็นระดับ Staff หรือ Principal
คุยไปคุยมาได้ไอเดียที่จริงๆแล้วใกล้ตัวมาก แต่ไม่เคยคิดให้ลึกซึ้งมาก่อน เลยมาเล่าให้ฟังครับ
เรามักจะได้ยินคำว่า Definition of Done (DoD) กันบ่อยในโลกของอไจล์ หลักๆเลยก็มักจะระบุว่างานจะเสร็จต้องมีเทสต์ครบ ต้องพร้อมขึ้นโปรดักชั่น (Releasable) ฯลฯ
สำหรับโปรแกรมเมอร์ทั่วไป พองานผ่าน DoD แล้วก็ถือว่าจบ ไปนั่งทำ Ticket/Feature/Issue ใหม่ๆต่อได้
แต่เมนเตอร์เค้าให้คิดต่อว่า จริงๆแล้วทำจบ DoD มันยังไม่เกิด Impact อะไรเลย โดยเฉพาะงานที่ใหญ่ๆ อย่างเช่น Feature หรือ Product ใหม่ๆ การที่จะทำให้งานเรามีความหมาย (หรือ Impact) มันจะต้องไปไกลเกิน DoD ซึ่งเป็นที่มาของไอเดียของ Definition of Success
ยกตัวอย่างเช่น ถ้าเป็น Feature เราก็ต้องดูต่อด้วยมีคนใช้งานจริงรึเปล่า ส่งผลต่อยอดขายเพิ่มขึ้นไหม มี Feedback ที่เป็นบวกจากลูกค้าหรือเปล่า
พวกนี้เป็นอะไรที่เราต้องคิดและมี Definition ที่ชัดเจน เพราะมันมักจะค่อนข้างวัดยาก (เช่น เราจะรู้ได้ไงว่ายอดขายที่เพิ่มขึ้นปีนี้มาจากฟีเจอร์ใหม่ ไม่ใช่แค่เพราะเผอิญคนซื้อของเยอะขึ้น)
พอมองที่ภาพใหญ่ขึ้น จะทำให้เห็นว่า Impact ของงานเราไม่ได้มีแค่เขียนโปรแกรมให้เสร็จ บางครั้ง เราก็ต้องสวมหมวกหน้าที่อื่นนอกเหนือจากการเป็นโปรแกรมเมอร์ด้วย หรือบางที เราก็ต้องต่อยอดไปคุยกับทีมอื่นๆด้วย เช่น Marketing, Business เพื่อให้ผลงานของเรามี Impact จริงๆ</description></item><item><title>คิดและวางแผนก่อน(แก้)โค้ด</title><link>https://www.notaboutcode.com/post/33-think-before-code/</link><pubDate>Sat, 26 Feb 2022 15:05:28 +0100</pubDate><guid>https://www.notaboutcode.com/post/33-think-before-code/</guid><description>อีกหนึ่งในนิสัยที่ผมเห็นโปรแกรมเมอร์เก่งๆมีกัน คือเค้าจะคิดค่อนข้างถี่ถ้วนลงมือเขียน(หรือแก้)โค้ด พอคุยกันเสร็จ เค้าจะหยิบสมุดหรือกระดาษขึ้นมาขีดๆเขียนๆไดอะแกรม เพื่อเช็คความเข้าใจก่อนก่อน เพื่อให้มีแผนคร่าวๆในหัวก่อนจะเริ่มเขียน . ในทางตรงกันข้าม จูเนียร์โปรแกรมเมอร์หลายคน พอคุยกันยังไม่ทันเสร็จดี จะเปิดไฟล์ขึ้นมา คิดอะไรไม่ออกใส่ For loop ทันทีเลย ไม่ได้เช็คดูด้วยซ้ำว่าไอ้โค้ดที่จะแก้นี่มันรันผ่านอยู่รึเปล่า . อันนี้ผมเจอบ่อยมาก พอผ่านไปสองช.ม. ก็จะเห็นว่านั่งงมบั๊ก ไม่แน่ใจว่าพังตรงไหน . คำถามคือ ควรจะคิดอะไร วางแผนอะไรบ้าง?​ ผมเสนอดังนี้ครับ .
ทำความเข้าใจโค้ดปัจจุบันก่อน . ถ้าไม่ใช่โค้ดที่เค้าเขียนประจำ สิ่งแรกที่ต้องทำคือเริ่มคุ้ยโค้ดครับ ถ้าส่วนที่ต้องแก้จะโดนหลาย Object เราควรจะเริ่มจากเขียนคลาสต่างๆลงในกระดาษ แล้วขีดเส้นโยงกันไปมาว่ามันมีความสัมพันธ์กันยังไง . ถ้าโค้ดตรงไหนอ่านยาก ไม่ค่อยเข้าใจ ลองจะหยิบเทสต์มานั่งรันดู หรือเติมเทสต์เพื่อลองเช็คสมมติฐานว่าเข้าใจโค้ดส่วนที่จะแก้จริงๆ ถ้าไม่มีเทสต์โค้ด ก็ลองปริ้นท์ค่าต่างๆออกมานั่งดู หรือกดไล่ใน Debugger ดูก่อน . . กำหนด input และ output ของโค้ดส่วนที่จะแก้ . ถ้ายังไม่รู้ว่าข้อมูลขาเข้าและขาออกเป็นอะไร เขียนโค้ดให้ถูกไม่ได้หรอกครับ . กรณีที่เราเติม Method ใหม่เข้าไป Input กับ Output ก็คือ Method signature นั่นเอง พยายามกำหนดให้ชัดเจนก่อนเขียนไส้ในลงไป ส่วน . กรณีที่มีหลาย Object ก็พยายามกำหนดให้ interface ว่าแค่ละ Object จะรับส่งค่าอะไร ผ่าน Method ไหนบ้าง ลำดับการเรียกเป็นยังไง ถ้าซับซ้อนมาก ลองเขียน Sequence diagram ออกมาก่อนก็ดี .</description></item><item><title>เขียนโค้ดให้เหมือนเต่า จะไปได้เร็วกว่ากระต่าย</title><link>https://www.notaboutcode.com/post/32-code-slowly-to-be-fast/</link><pubDate>Sat, 26 Feb 2022 15:05:28 +0100</pubDate><guid>https://www.notaboutcode.com/post/32-code-slowly-to-be-fast/</guid><description>&lt;p>&lt;img src="https://www.notaboutcode.com/img/covers/turtle-01.png" alt="Photo by Tanguy Sauvin on Unsplash">&lt;/p>
&lt;p>สำหรับคนที่พึ่งเขียนโค้ดใหม่ๆ ผมแนะนำว่าให้พยายามเขียนโค้ดทีละนิด อย่าเขียนรวดเดียวครับ&lt;/p>
&lt;p>ผมสังเกตว่าคนที่เขียนโค้ดได้ดี จะมีพฤติกรรมหลายอย่างคล้ายๆกัน หนึ่งในพฤติกรรมที่ผมเห็นบ่อย คือเค้าจะแก้โค้ดทีละนิด แล้วค่อยๆรันดูว่าทำงานถูกต้องตามที่คิดไว้ไหม พอทำถูกแล้ว ก็จะค่อยเติมโค้ดเข้าไปต่อ&lt;/p>
&lt;p>แต่ละรอบ เค้าจะแก้โค้ดแค่ไม่เกินห้าบรรทัด&lt;/p>
&lt;p>ตัวอย่างเช่น ผมอยากจะเขียน API เพื่อรับค่าจาก Array มาคำนวนแล้วส่งค่า Sum กลับไป ผมจะเขียนแต่ละรอบดังนี้&lt;/p></description></item><item><title>มาทำความรู้จักกับ Serverless กัน</title><link>https://www.notaboutcode.com/post/26-serverless-architecture/</link><pubDate>Sat, 01 Sep 2018 12:04:02 +0700</pubDate><guid>https://www.notaboutcode.com/post/26-serverless-architecture/</guid><description>&lt;p>&lt;img src="https://www.notaboutcode.com/img/covers/aurora-01.jpg" alt="Photo by Nicolas J Leclercq on Unsplash">&lt;/p>
&lt;p>ช่วงสองปีที่ผ่านมา แนวคิดหนึ่งที่ผมจับตาดูอยู่คือเรื่องของ Serverless&lt;/p>
&lt;p>ตามชื่อเลย Serverless คือไม่มีเซอร์เวอร์ ซึ่งจริงๆแล้วเซอร์เวอร์ก็ไม่ได้หายไปไหน เพียงแต่ทีมพัฒนาไม่ต้องสนใจมันเหมือนแต่ก่อนแล้ว&lt;/p>
&lt;p>แนวคิดเรื่องนี้ยังถือว่าค่อนข้างใหม่ เมื่อสองปีที่แล้วผมทดลองใช้ครั้งแรกเพื่อดูว่าเอาไปใช้ทำโปรเจ็คจริงได้รึเปล่า ก็ค้นพบว่าพวก Tool และ Practices ต่างๆยังไม่พร้อมเท่าไร&lt;/p>
&lt;p>ผ่านมาสองปี รู้สึกว่าเริ่มเข้าที่เข้าทางมากขึ้น จึงพึ่งได้เอามาใช้ทำโปรเจ็คจริง เลยเอามาเล่าสู่กันฟังครับ เผื่อใครอยากจะลองเอาไปใช้กัน&lt;/p></description></item><item><title>การนำ Agile มาใช้ในองค์กร</title><link>https://www.notaboutcode.com/post/25-advices-for-adopting-agile/</link><pubDate>Sat, 23 Jun 2018 12:04:02 +0700</pubDate><guid>https://www.notaboutcode.com/post/25-advices-for-adopting-agile/</guid><description>&lt;p>&lt;img src="https://www.notaboutcode.com/img/covers/collaboration-01.jpg" alt="Photo by rawpixel on Unsplash">&lt;/p>
&lt;p>ผมรู้จักกับ Agile (อไจล์) เมื่อสิบกว่าปีที่แล้ว ตอนนั้นก็ไม่รู้หรอกว่ามันจะป๊อบขนาดนี้ สมัยนั้นอย่าพูดถึงอไจล์เลย ทีมไหนทำ Unit Testing ก็ถือว่าหรูแล้ว&lt;/p>
&lt;blockquote>
&lt;p>ฝั่ง UK จะออกเสียงว่า อา-ไจล์, ฝั่ง US จะอ่านออกเสียว่า แอ-ไจล์ ในบทความนี้จะขอใช้ทับศัพท์ว่าอไจล์ซึ่งเป็นที่นิยมใช้กันนะครับ &amp;ndash; &lt;a href="https://dictionary.cambridge.org/pronunciation/english/agile">https://dictionary.cambridge.org/pronunciation/english/agile&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>ด้วยความที่คลุกคลีอยู่กับเรื่องนี้ตั้งแต่ยุคที่อไจล์เข้ามาแรกๆ เลยได้เห็นการเปลี่ยนแปลงตั้งแต่สมัยที่ผู้บริหารรู้สึกว่าทีมที่ทำอไจล์คือการก่อกบฏ จนถึงปัจจุบันนี้ ถ้าทีมไหนไม่ทำอไจล์แล้วจะกลายเป็นกบฏแทน&lt;/p>
&lt;p>ผมเชื่อว่าผู้บริหารระดับสูงที่กล้าจะเลือกใช้อไจล์นั้นมีวิสัยทัศน์ที่ดี แต่เวลาปฏิบัติจริง ผมกลับเห็นว่าหลายที่ได้ผลลัพธ์เละเทะมาก สุดท้ายก็มาจบลงที่ว่าอไจล์ไม่ดี หรือไม่เหมาะกับองค์กร (ซึ่งก็อาจจะเป็นไปได้) หรือบางที่ก็เลือกที่จะซุกปัญหาไว้ใต้พรม แล้วทำ KPI ให้ดูสวยๆว่าผลลัพธ์ออกมาดี&lt;/p>
&lt;p>สุดท้ายกลายเป็นตราบาปให้กับอไจล์ เป็นแผลเป็นให้กับพนักงานในบริษัท ที่ขยาดทุกครั้งที่ได้ยินคำนี้&lt;/p>
&lt;p>ผมเลยอยากเขียนบทความนี้ไว้ให้ผู้บริหาร และหัวหน้าทีมพัฒนา (Technical Lead/ Team Lead) เพราะทัศนคติที่ถูกต้องต่ออไจล์จะส่งผลกระทบต่อการรับอไจล์เข้ามาในองค์กรมาก&lt;/p>
&lt;p>บทความนี้จะพูดถึงข้อแนะนำ และตัวอย่างกรณีที่ดี/ไม่ดีแบบต่างๆ ในการนำอไจล์เข้ามาในองค์กร โดยผู้เขียนอนุมานว่าผู้อ่านรู้จักอไจล์และ Scrum แล้ว หากใครที่ยังไม่เข้าใจคำพวกนี้ แนะนำให้อ่านบทความอื่นก่อนครับ&lt;/p></description></item></channel></rss>